import { FrameLocator, Locator, Page } from '@playwright/test';

/**
 * UI Interactions utility class for handling common tricky UI interactions
 * with built-in fallback mechanisms for more reliable test automation
 * 
 * Table Verification Usage Guide:
 * 
 * 1. Basic verification of table values:
 *    ```typescript
 *    // Use the verifyTableValues method directly
 *    const result = await UIInteractions.verifyTableValues(rowLocator, {
 *      selector: "td.price",          // CSS selector for the cell
 *      expectedValue: "49.99",        // Expected value to match
 *      description: "Product price"   // Description for logging
 *    });
 *    
 *    if (!result.success) {
 *      console.log(result.message);   // Get detailed error message
 *    }
 *    ```
 * 
 * 2. Verifying highlighted values vs input values:
 *    ```typescript
 *    // For displayed text values (highlighted in UI)
 *    await verifyProductInTable({...}, { checkHighlightedValues: true });
 *    
 *    // For input values (default)
 *    await verifyProductInTable({...}, { checkHighlightedValues: false });
 *    ```
 * 
 * 3. Format matching for cleaner comparisons:
 *    ```typescript
 *    // Enable format matching to normalize values before comparison
 *    await verifyProductInTable({...}, { formatMatch: true });
 *    
 *    // Examples of what format matching handles:
 *    // - "$49.99" will match "49.99" (currency symbols removed)
 *    // - "1,234.56" will match "1234.56" (commas removed)
 *    // - "49.99" will match "49.990" (numeric comparison)
 *    ```
 */
export class UIInteractions {
    /**
     * Verifies text content in tables, supporting various formats and handling highlighted values
     * @param tableRow - The Playwright locator for the table row
     * @param options - Configuration options for verification
     * @returns Promise<{ success: boolean, actual: Record<string, string | null>, message: string }>
     */
    static async verifyTableValues(
        tableRow: Locator,
        options: {
            selector: string;
            expectedValue: string;
            description?: string;
            isAttribute?: boolean;
            attributeName?: string;
            timeout?: number;
            formatMatch?: boolean; // Whether to normalize formats (e.g., currency symbols, spacing)
            formatOptions?: {
                removeSymbols?: boolean; // Remove currency symbols, commas, etc.
                ignoreCasing?: boolean; // Ignore case differences
                numericCompare?: boolean; // Compare as numbers instead of strings
            };
            valueType?: 'text' | 'input' | 'both'; // Where to look for the value
            retryOnNotFound?: boolean; // Whether to retry if element not found
        }
    ): Promise<{ success: boolean, actual: string | null, message: string }> {
        const {
            selector,
            expectedValue,
            description = 'table value',
            isAttribute = false,
            attributeName = 'value',
            timeout = 5000,
            formatMatch = false,
            formatOptions = {
                removeSymbols: true,
                ignoreCasing: true,
                numericCompare: false
            },
            valueType = 'both',
            retryOnNotFound = true
        } = options;

        try {
            // Check if table row exists before proceeding
            try {
                await tableRow.waitFor({ state: 'visible', timeout: timeout / 2 });
                console.log(`Table row for "${description}" is visible, proceeding with verification`);
            } catch (rowError) {
                console.error(`Table row for "${description}" is not visible: ${rowError}`);
                return { 
                    success: false, 
                    actual: null, 
                    message: `Failed to find table row for ${description}: ${rowError instanceof Error ? rowError.message : String(rowError)}`
                };
            }
            
            // Create cell locator and wait with proper error handling
            const cellLocator = selector ? tableRow.locator(selector) : tableRow;
            let cellVisible = false;
            
            try {
                await cellLocator.waitFor({ state: 'visible', timeout: timeout / 2 });
                console.log(`Cell locator for "${description}" (selector: ${selector || 'direct'}) is visible`);
                cellVisible = true;
            } catch (cellError) {
                console.error(`Cell locator for "${description}" (selector: ${selector || 'direct'}) is not visible: ${cellError}`);
                
                if (retryOnNotFound) {
                    // Wait a bit and try again with a more relaxed approach
                    console.log(`Retrying with a more relaxed approach for "${description}"`);
                    await new Promise(r => setTimeout(r, 1000)); // Short delay
                    
                    // Try to check if the element exists even if not visible
                    const exists = await cellLocator.count() > 0;
                    if (!exists) {
                        return { 
                            success: false, 
                            actual: null, 
                            message: `Failed to find cell for ${description} using selector "${selector || 'direct'}": Element not found in DOM`
                        };
                    }
                } else {
                    return { 
                        success: false, 
                        actual: null, 
                        message: `Failed to find cell for ${description} using selector "${selector || 'direct'}": ${cellError instanceof Error ? cellError.message : String(cellError)}`
                    };
                }
            }
            
            // Get actual value based on valueType with error handling
            let actualValue: string | null = null;
            let inputValue: string | null = null;
            let textValue: string | null = null;
            
            try {
                // Get input value if requested
                if (valueType === 'input' || valueType === 'both') {
                    if (isAttribute) {
                        try {
                            inputValue = await cellLocator.getAttribute(attributeName);
                            console.log(`Got attribute ${attributeName} value for ${description}: ${inputValue}`);
                        } catch (attrError) {
                            console.warn(`Failed to get attribute ${attributeName} for ${description}: ${attrError}`);
                        }
                    } else {
                        // Try to get value from input element within the cell
                        try {
                            const inputLocator = cellLocator.locator('input');
                            if (await inputLocator.count() > 0) {
                                inputValue = await inputLocator.getAttribute('value');
                                console.log(`Got input value for ${description}: ${inputValue}`);
                            }
                        } catch (inputError) {
                            console.warn(`Failed to get input value for ${description}: ${inputError}`);
                        }
                    }
                }
                
                // Get text content if requested
                if (valueType === 'text' || valueType === 'both') {
                    try {
                        textValue = await cellLocator.textContent();
                        console.log(`Got text content for ${description}: ${textValue}`);
                    } catch (textError) {
                        console.warn(`Failed to get text content for ${description}: ${textError}`);
                    }
                }
            } catch (valueError) {
                console.error(`Error getting values for ${description}: ${valueError}`);
            }
            
            // Prioritize the value type requested, or use what's available
            if (valueType === 'input') {
                actualValue = inputValue;
            } else if (valueType === 'text') {
                actualValue = textValue;
            } else {
                // For 'both', prefer text content unless it's empty, then use input value
                actualValue = textValue?.trim() ? textValue : inputValue;
            }
            
            console.log(`Final actual value for ${description}: ${actualValue}`);
            
            // Format values if needed
            if (formatMatch && actualValue && expectedValue) {
                const formatValue = (value: string) => {
                    let formattedValue = value.trim();
                    
                    if (formatOptions.removeSymbols) {
                        // Remove currency symbols, commas, etc.
                        formattedValue = formattedValue.replace(/[$,€£¥]/g, '');
                    }
                    
                    if (formatOptions.ignoreCasing) {
                        formattedValue = formattedValue.toLowerCase();
                    }
                    
                    if (formatOptions.numericCompare) {
                        // Extract numbers from the string
                        const numMatch = formattedValue.match(/[\d.]+/);
                        if (numMatch) {
                            formattedValue = numMatch[0];
                        }
                    }
                    
                    return formattedValue;
                };
                
                const formattedActual = formatValue(actualValue);
                const formattedExpected = formatValue(expectedValue);
                
                console.log(`Formatted values for ${description}: Expected="${formattedExpected}", Actual="${formattedActual}"`);
                
                if (formatOptions.numericCompare) {
                    // Compare as numbers
                    const actualNum = parseFloat(formattedActual);
                    const expectedNum = parseFloat(formattedExpected);
                    
                    if (!isNaN(actualNum) && !isNaN(expectedNum) && actualNum === expectedNum) {
                        return { 
                            success: true, 
                            actual: actualValue,
                            message: `${description} matches the expected value (${expectedValue}) after formatting`
                        };
                    }
                } else if (formattedActual === formattedExpected) {
                    return { 
                        success: true, 
                        actual: actualValue,
                        message: `${description} matches the expected value (${expectedValue}) after formatting` 
                    };
                }
            } else if (actualValue === expectedValue) {
                // Direct match without formatting
                return { 
                    success: true, 
                    actual: actualValue,
                    message: `${description} matches the expected value (${expectedValue})` 
                };
            }
            
            // No match found
            return {
                success: false,
                actual: actualValue,
                message: `${description} does not match the expected value. Expected: "${expectedValue}", Found: "${actualValue}"`
            };
        } catch (error) {
            console.error(`Error verifying ${description}:`, error);
            return { 
                success: false, 
                actual: null,
                message: `Failed to verify ${description}: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }
    }

    /**
     * Robust method to check a checkbox or radio button with multiple fallback approaches
     * @param locator - The Playwright locator for the checkbox/radio
     * @param options - Optional configuration options
     * @returns Promise<boolean> - True if successful, false otherwise
     */
    static async checkElement(
        locator: Locator,
        options: {
            timeout?: number;
            description?: string;
            page?: Page;
            iframe?: string;
        } = {}
    ): Promise<boolean> {
        const description = options.description || 'element';
        const timeout = options.timeout || 5000;
        
        try {
            // Approach 1: Standard check with force
            try {
                await locator.waitFor({ state: 'visible', timeout });
                await locator.check({ force: true, timeout });
                console.log(`Successfully checked ${description} using standard approach`);
                return true;
            } catch (error) {
                console.log(`Standard check failed for ${description}, trying alternative approaches...`);
            }

            // Approach 2: Click instead of check
            try {
                await locator.click({ force: true, timeout });
                console.log(`Successfully clicked ${description} as alternative to check`);
                return true;
            } catch (clickError) {
                console.log(`Click approach failed for ${description}`);
            }

            // Approach 3: JavaScript execution in the main document
            try {
                await locator.evaluate((element: HTMLElement) => {
                    if (element.tagName === 'INPUT') {
                        const inputElement = element as HTMLInputElement;
                        if (inputElement.type === 'checkbox' || inputElement.type === 'radio') {
                            inputElement.checked = true;
                            element.dispatchEvent(new Event('change', { bubbles: true }));
                            element.dispatchEvent(new Event('input', { bubbles: true }));
                            element.dispatchEvent(new Event('click', { bubbles: true }));
                        } else {
                            element.click();
                        }
                        return true;
                    } else {
                        element.click();
                        return true;
                    }
                    return false;
                });
                console.log(`Successfully used JS to check ${description}`);
                return true;
            } catch (jsError) {
                console.log(`JS execution approach failed for ${description}`);
            }

            // Approach 4: If we have page and iframe information, try within iframe
            if (options.page && options.iframe) {
                try {
                    const frame = options.page.frame(options.iframe);
                    if (frame) {
                        // We need to reconstruct the selector for the frame context
                        // This is a bit complex and depends on how your locator was created
                        const selector = await locator.evaluate((el: Element) => {
                            let path = '';
                            let currentElement: Element | null = el;
                            while (currentElement && currentElement !== document.documentElement) {
                                const tagName = currentElement.tagName.toLowerCase();
                                let index = 0;
                                let sibling: Element | null = currentElement;
                                while (sibling.previousElementSibling) {
                                    sibling = sibling.previousElementSibling;
                                    if (sibling && sibling.tagName.toLowerCase() === tagName) {
                                        index++;
                                    }
                                }
                                path = `${tagName}${index > 0 ? `:nth-of-type(${index + 1})` : ''}${path ? ' > ' + path : ''}`;
                                currentElement = currentElement.parentElement;
                            }
                            return path;
                        }).catch(() => null);
                        
                        if (selector) {
                            await frame.evaluate((selector: string) => {
                                const element = document.querySelector(selector);
                                if (element && element instanceof HTMLInputElement && 
                                   (element.type === 'checkbox' || element.type === 'radio')) {
                                    element.checked = true;
                                    element.dispatchEvent(new Event('change', { bubbles: true }));
                                    return true;
                                }
                                return false;
                            }, selector);
                            console.log(`Successfully used iframe JS approach for ${description}`);
                            return true;
                        }
                    }
                } catch (frameError) {
                    console.log(`Iframe JS approach failed for ${description}`);
                }
            }

            console.log(`All approaches failed for checking ${description}`);
            return false;
        } catch (error) {
            console.error(`Error in checkElement for ${description}:`, error);
            return false;
        }
    }

    /**
     * Robust method to uncheck a checkbox with multiple fallback approaches
     * @param locator - The Playwright locator for the checkbox
     * @param options - Optional configuration options
     * @returns Promise<boolean> - True if successful, false otherwise
     */
    static async uncheckElement(
        locator: Locator,
        options: {
            timeout?: number;
            description?: string;
        } = {}
    ): Promise<boolean> {
        const description = options.description || 'element';
        const timeout = options.timeout || 5000;
        
        try {
            // Approach 1: Standard uncheck with force
            try {
                await locator.waitFor({ state: 'visible', timeout });
                await locator.uncheck({ force: true, timeout });
                console.log(`Successfully unchecked ${description} using standard approach`);
                return true;
            } catch (error) {
                console.log(`Standard uncheck failed for ${description}, trying alternative approaches...`);
            }

            // Approach 2: Click instead of uncheck (will toggle)
            try {
                await locator.click({ force: true, timeout });
                console.log(`Successfully clicked ${description} as alternative to uncheck`);
                return true;
            } catch (clickError) {
                console.log(`Click approach failed for ${description}`);
            }

            // Approach 3: JavaScript execution
            try {
                await locator.evaluate((element: HTMLElement) => {
                    if (element.tagName === 'INPUT') {
                        const inputElement = element as HTMLInputElement;
                        if (inputElement.type === 'checkbox') {
                            inputElement.checked = false;
                            element.dispatchEvent(new Event('change', { bubbles: true }));
                            element.dispatchEvent(new Event('input', { bubbles: true }));
                            return true;
                        }
                    }
                    return false;
                });
                console.log(`Successfully used JS to uncheck ${description}`);
                return true;
            } catch (jsError) {
                console.log(`JS execution approach failed for ${description}`);
            }

            console.log(`All approaches failed for unchecking ${description}`);
            return false;
        } catch (error) {
            console.error(`Error in uncheckElement for ${description}:`, error);
            return false;
        }
    }

    /**
     * Robust method to fill an input field with multiple fallback approaches
     * @param locator - The Playwright locator for the input
     * @param value - The value to fill
     * @param options - Optional configuration options
     * @returns Promise<boolean> - True if successful, false otherwise
     */
    static async fillInput(
        locator: Locator,
        value: string,
        options: {
            timeout?: number;
            description?: string;
            clearFirst?: boolean;
        } = {}
    ): Promise<boolean> {
        const description = options.description || 'input field';
        const timeout = options.timeout || 5000;
        const clearFirst = options.clearFirst !== undefined ? options.clearFirst : true;
        
        try {
            // Approach 1: Standard fill
            try {
                await locator.waitFor({ state: 'visible', timeout });
                if (clearFirst) {
                    await locator.clear({ timeout });
                }
                await locator.fill(value, { timeout });
                console.log(`Successfully filled ${description} using standard approach`);
                return true;
            } catch (error) {
                console.log(`Standard fill failed for ${description}, trying alternative approaches...`);
            }

            // Approach 2: Type instead of fill
            try {
                if (clearFirst) {
                    await locator.clear({ timeout });
                }
                await locator.type(value, { timeout });
                console.log(`Successfully typed into ${description} as alternative to fill`);
                return true;
            } catch (typeError) {
                console.log(`Type approach failed for ${description}`);
            }

            // Approach 3: JavaScript execution
            try {
                await locator.evaluate((element: HTMLElement, val: string) => {
                    if (element instanceof HTMLInputElement || 
                        element instanceof HTMLTextAreaElement || 
                        element instanceof HTMLSelectElement) {
                        element.value = val;
                        element.dispatchEvent(new Event('input', { bubbles: true }));
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        return true;
                    }
                    return false;
                }, value);
                console.log(`Successfully used JS to fill ${description}`);
                return true;
            } catch (jsError) {
                console.log(`JS execution approach failed for ${description}`);
            }

            console.log(`All approaches failed for filling ${description}`);
            return false;
        } catch (error) {
            console.error(`Error in fillInput for ${description}:`, error);
            return false;
        }
    }

    /**
     * Robust method to select an option from a dropdown with multiple fallback approaches
     * @param locator - The Playwright locator for the select element
     * @param optionValue - The value or label of the option to select
     * @param options - Optional configuration options
     * @returns Promise<boolean> - True if successful, false otherwise
     */
    static async selectOption(
        locator: Locator,
        optionValue: string,
        options: {
            timeout?: number;
            description?: string;
            byValue?: boolean; // true to select by value, false to select by label
        } = {}
    ): Promise<boolean> {
        const description = options.description || 'dropdown';
        const timeout = options.timeout || 5000;
        const byValue = options.byValue !== undefined ? options.byValue : true;
        
        try {
            // Approach 1: Standard selectOption
            try {
                await locator.waitFor({ state: 'visible', timeout });
                if (byValue) {
                    await locator.selectOption({ value: optionValue }, { timeout });
                } else {
                    await locator.selectOption({ label: optionValue }, { timeout });
                }
                console.log(`Successfully selected option in ${description} using standard approach`);
                return true;
            } catch (error) {
                console.log(`Standard select failed for ${description}, trying alternative approaches...`);
            }

            // Approach 2: JavaScript execution
            try {
                // Pass in parameters as a single object to work around TypeScript evaluation limitations
                const params = { value: optionValue, byValue };
                await locator.evaluate((element: HTMLElement, params: { value: string, byValue: boolean }) => {
                    if (element instanceof HTMLSelectElement) {
                        const options = Array.from(element.options);
                        if (params.byValue) {
                            // Select by value
                            const option = options.find(opt => opt.value === params.value);
                            if (option) {
                                element.value = option.value;
                                element.dispatchEvent(new Event('change', { bubbles: true }));
                                return true;
                            }
                        } else {
                            // Select by text
                            const option = options.find(opt => opt.text === params.value);
                            if (option) {
                                element.value = option.value;
                                element.dispatchEvent(new Event('change', { bubbles: true }));
                                return true;
                            }
                        }
                    }
                    return false;
                }, params);
                console.log(`Successfully used JS to select option in ${description}`);
                return true;
            } catch (jsError) {
                console.log(`JS execution approach failed for ${description}`);
            }

            console.log(`All approaches failed for selecting option in ${description}`);
            return false;
        } catch (error) {
            console.error(`Error in selectOption for ${description}:`, error);
            return false;
        }
    }
}